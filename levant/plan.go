// Copyright (c) HashiCorp, Inc.
// SPDX-License-Identifier: MPL-2.0

package levant

import (
	"encoding/json"
	"fmt"
	"os"
	"strings"

	"github.com/hashicorp/levant/client"
	"github.com/hashicorp/levant/levant/structs"
	"github.com/hashicorp/levant/output"
	nomad "github.com/hashicorp/nomad/api"
	"github.com/rs/zerolog/log"
)

const (
	diffTypeAdded   = "Added"
	diffTypeEdited  = "Edited"
	diffTypeDeleted = "Deleted"
	diffTypeNone    = "None"

	typeJob       = "job"
	typeTaskGroup = "taskgroup"
	typeTask      = "task"
	typeObject    = "object"
	typeEndObject = "end_object"
	typeField     = "field"

	operatorAdded   = " + "
	operatorDeleted = " - "
	operatorEdited  = "+/-"
	operatorNone    = "   "
)

type levantPlan struct {
	nomad  *nomad.Client
	config *structs.LevantPlanConfig
}

func newPlan(config *structs.LevantPlanConfig) (*levantPlan, error) {

	var err error

	plan := &levantPlan{}
	plan.config = config

	plan.nomad, err = client.NewNomadClient(config.Client.Addr)
	if err != nil {
		return nil, err
	}
	return plan, nil
}

// TriggerPlan initiates a Levant plan run.
func TriggerPlan(config *structs.LevantPlanConfig) (bool, bool) {

	lp, err := newPlan(config)
	if err != nil {
		log.Error().Err(err).Msg("levant/plan: unable to setup Levant plan")
		return false, false
	}

	changes, err := lp.plan()
	if err != nil {
		log.Error().Err(err).Msg("levant/plan: error when running plan")
		return false, changes
	}

	if !changes && lp.config.Plan.IgnoreNoChanges {
		log.Info().Msg("levant/plan: no changes found in job but ignore-no-changes flag set to true")
	} else if !changes && !lp.config.Plan.IgnoreNoChanges {
		log.Info().Msg("levant/plan: no changes found in job")
		return false, changes
	}

	return true, changes
}

// plan is the entry point into running the Levant plan function which logs all
// changes anticipated by Nomad of the upcoming job registration. If there are
// no planned changes here, return false to indicate we should stop the process.
func (lp *levantPlan) plan() (bool, error) {

	log.Debug().Msg("levant/plan: triggering Nomad plan")

	// Run a plan using the rendered job.
	resp, _, err := lp.nomad.Jobs().Plan(lp.config.Template.Job, true, nil)
	if err != nil {
		log.Error().Err(err).Msg("levant/plan: unable to run a job plan")
		return false, err
	}

	switch resp.Diff.Type {

	// If the job is new, then don't print the entire diff but just log that it
	// is a new registration.
	case diffTypeAdded:
		log.Info().Msg("levant/plan: job is a new addition to the cluster")
		return true, nil

		// If there are no changes, log the message so the user can see this and
		// exit the deployment.
	case diffTypeNone:
		log.Info().Msg("levant/plan: no changes detected for job")
		return false, nil

		// If there are changes, run the planDiff function which is responsible for
		// iterating through the plan and logging all the planned changes.
	case diffTypeEdited:
		outputDiff(lp.config.Output, resp.Diff)
	}

	return true, nil
}

func outputDiff(config *structs.DiffOutputConfig, diff *nomad.JobDiff) {
	var outFun func(string)

	switch *config.Destination {
	case output.OutLog:
		outFun = func(out string) {
			log.Info().Msgf("levant/plan: %s", out)
		}
	case output.OutCLI:
		outFun = func(out string) {
			(*config.UI).Output(out)
		}
	case output.OutSTDOUT:
		outFun = func(out string) {
			fmt.Println(out)
		}
	case output.OutSTDERR:
		outFun = func(out string) {
			fmt.Fprintln(os.Stderr, out)
		}
	}
	switch *config.Format {
	case output.FmtJSON:
		printDiffAsJSON(diff, outFun)
	case output.FmtDiff:
		parsedPlan := parsePlanJSON(diff)
		printLinesAsText(parsedPlan, outFun)
	case output.FmtNDJSON:
		parsedPlan := parsePlanJSON(diff)
		printLinesAsJSON(parsedPlan, outFun)
	}
	return
}

func printDiffAsJSON(diff *nomad.JobDiff, outFun func(string)) {
	out, err := json.Marshal(diff)
	if err != nil {
		log.Error().Msgf("levant/plan: failed to marshall plan to JSON: %s", err.Error())
		return
	}
	outFun(string(out))
	return
}

// JSONLine contains a single JSON element generated by the formatPlanJSON
// function. This forms the basis of the json log line and is converted to
// plaintext for some output options. This could also be converted to html
// or other output alternatives.
type JSONLine struct {
	// The item that has changed
	Item string `json:"item"`
	// What sort of object that item is (job, taskgroup, task, object)
	Type string `json:"type"`
	// The depth, necessary for padding. The shallowest object (the job) is at depth=0
	Depth int `json:"depth"`
	// The operation that is happening to the object: add, remove, etc.
	Operation string `json:"operation"`
	// Previous value of fields that are being edited or deleted
	Before string `json:"before"`
	// New value for fields being added or edited
	After string `json:"after"`
	// List of string annotations from the scheduler
	Annotations []string `json:"annotations"`
}

func createJSONLine(item string, inType string, depth int, oper string, before string, after string, ann []string) *JSONLine {
	outJSON := &JSONLine{
		Item:        item,
		Type:        inType,
		Depth:       depth,
		Operation:   oper,
		Before:      before,
		After:       after,
		Annotations: ann,
	}
	return outJSON
}

func createJobLine(item string, depth int, oper string) *JSONLine {
	return createJSONLine(item, typeJob, depth, oper, "", "", nil)
}

func createTaskgroupLine(item string, depth int, oper string, updates map[string]uint64) *JSONLine {
	ann := make([]string, 0, 5)

	for updateType, count := range updates {
		ann = append(ann, fmt.Sprintf("%d %s", count, updateType))
	}
	return createJSONLine(item, typeTaskGroup, depth, oper, "", "", ann)
}

func createTaskLine(item string, depth int, oper string, ann []string) *JSONLine {
	return createJSONLine(item, typeTask, depth, oper, "", "", ann)
}

func createObjectLine(item string, depth int, oper string) *JSONLine {
	return createJSONLine(item, typeObject, depth, oper, "", "", nil)
}

func createEndObjectLine(item string, depth int, oper string) *JSONLine {
	return createJSONLine(item, typeEndObject, depth, oper, "", "", nil)
}

func createFieldLine(item string, depth int, oper string, before string, after string, ann []string) *JSONLine {
	return createJSONLine(item, typeField, depth, oper, before, after, ann)
}

// parsePlanJSON builds a newline delimited JSON which can
// then be formatted before emitting to the log.
func parsePlanJSON(plan *nomad.JobDiff) []*JSONLine {
	lines := make([]*JSONLine, 0, 100)
	var depth int = 0
	lines = append(lines, createJobLine(plan.ID, 0, plan.Type))
	depth = depth + 1
	lines = append(lines, parseFieldDiffs(plan.Fields, depth)...)
	lines = append(lines, parseObjectDiffs(plan.Objects, depth)...)
	for _, group := range plan.TaskGroups {
		lines = append(lines, parseTaskGroupDiff(group, depth)...)
	}
	return lines
}

func parseTaskGroupDiff(tg *nomad.TaskGroupDiff, depth int) []*JSONLine {
	lines := make([]*JSONLine, 0, 100)

	lines = append(lines, createTaskgroupLine(tg.Name, depth, tg.Type, tg.Updates))
	depth = depth + 1
	lines = append(lines, parseFieldDiffs(tg.Fields, depth)...)
	lines = append(lines, parseObjectDiffs(tg.Objects, depth)...)
	for _, task := range tg.Tasks {
		lines = append(lines, parseTaskDiff(task, depth)...)
	}
	return lines
}

func parseTaskDiff(task *nomad.TaskDiff, depth int) []*JSONLine {
	lines := make([]*JSONLine, 0, 100)
	lines = append(lines, createTaskLine(task.Name, depth, task.Type, task.Annotations))
	depth = depth + 1
	lines = append(lines, parseFieldDiffs(task.Fields, depth)...)
	lines = append(lines, parseObjectDiffs(task.Objects, depth)...)
	return lines
}

func parseObjectDiffs(objects []*nomad.ObjectDiff, depth int) []*JSONLine {
	lines := make([]*JSONLine, 0, 100)

	for _, object := range objects {
		lines = append(lines, createObjectLine(object.Name, depth, object.Type))
		depth = depth + 1
		lines = append(lines, parseFieldDiffs(object.Fields, depth)...)
		lines = append(lines, parseObjectDiffs(object.Objects, depth)...)
		depth = depth - 1
		lines = append(lines, createEndObjectLine(object.Name, depth, object.Type))
	}
	return lines
}

func parseFieldDiffs(fields []*nomad.FieldDiff, depth int) []*JSONLine {
	lines := make([]*JSONLine, 0, 20)

	for _, field := range fields {
		lines = append(lines, createFieldLine(field.Name, depth, field.Type, field.Old, field.New, field.Annotations))
	}
	return lines
}

func printLinesAsText(lines []*JSONLine, outFun func(string)) {
	for _, line := range lines {
		var operator, padding, body, annotations, out string
		padding = strings.Repeat("  ", line.Depth)

		if line.Annotations != nil {
			annotations = " (" + strings.Join(line.Annotations, ",") + ")"
		}

		switch line.Operation {
		case diffTypeAdded:
			operator = operatorAdded
			body = fmt.Sprintf("%s", formatValue(line.After))
		case diffTypeDeleted:
			operator = operatorDeleted
			body = fmt.Sprintf("%s", formatValue(line.Before))
		case diffTypeEdited:
			operator = operatorEdited
			body = fmt.Sprintf("%s => %s", formatValue(line.Before), formatValue(line.After))
		case diffTypeNone:
			operator = operatorNone
			body = fmt.Sprintf("%s", formatValue(line.Before))
		default:
			panic(fmt.Sprintf("reached default condition unexpectedly: %s", line.Type))
		}

		switch line.Type {
		case typeJob:
			out = fmt.Sprintf("%s%s Job \"%s\": %s", padding, operator, line.Item, annotations)
		case typeTaskGroup:
			out = fmt.Sprintf("%s%s Task Group \"%s\": %s", padding, operator, line.Item, annotations)
		case typeTask:
			out = fmt.Sprintf("%s%s Task \"%s\" %s", padding, operator, line.Item, annotations)
		case typeObject:
			out = fmt.Sprintf("%s%s %s {", padding, operator, line.Item)
		case typeEndObject:
			// override the incoming operator so the closing mark doesn't have
			// a sign
			operator = operatorNone
			out = fmt.Sprintf("%s%s }", padding, operator)
		case typeField:
			out = fmt.Sprintf("%s%s %s: %s", padding, operator, line.Item, body)
		default:
			panic(fmt.Sprintf("Unexpected line type: %s", line.Type))
		}

		outFun(out)
	}
}

func printLinesAsJSON(lines []*JSONLine, outFun func(string)) {
	var out string
	for _, line := range lines {
		switch line.Type {
		case typeEndObject:
			continue
		default:
			out = formatValue(line)
		}
		outFun(out)
	}
}

// formatValue formats the incoming value as JSON. If that isn't
// possible, it returns error text as the value
func formatValue(in interface{}) string {
	out, err := json.Marshal(in)
	if err == nil {
		return string(out)
	}
	return fmt.Sprintf("failed to marshal. err: %s", err.Error())
}
